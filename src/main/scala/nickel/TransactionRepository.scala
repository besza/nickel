package nickel

import scala.concurrent.{ExecutionContext, Future}

import java.time.format.DateTimeFormatter
import java.time.{Instant, LocalDate, YearMonth, ZoneOffset}

import io.vertx.core.json.JsonArray
import io.vertx.scala.ext.sql.{SQLClient, SQLOptions}

class TransactionRepository(val sqlClient: SQLClient)(implicit val ec: ExecutionContext) {

  def single(id: Id[Transaction]): Future[Option[StoredTransaction]] =
    sqlClient.queryWithParamsFuture(
      s"""SELECT "id", "created_at", "from", "to", "on", "amount", "description" FROM "transaction"
         |WHERE "id" = ?
      """.stripMargin,
      new JsonArray().add(id.value)
    ).map { resultSet =>
      resultSet.getResults.headOption
        .map { row =>
          StoredTransaction(
            id = Id(row.getLong(0)),
            createdAt = row.getInstant(1),
            transaction = Transaction(
              from = Id(row.getLong(2)),
              to = Id(row.getLong(3)),
              on = LocalDate.parse(row.getString(4), DateTimeFormatter.ISO_DATE),
              amount = Money(row.getInteger(5)),
              description = row.getString(6)
            )
          )
        }
    }

  def inMonth(month: YearMonth, account: Option[Id[Account]]): Future[List[StoredTransaction]] = {
    val accountClause = account.map { _ => """AND ("from" = ? OR "to" = ?)""" }.getOrElse("")
    val accountParams = account.map { id => new JsonArray().add(id.value).add(id.value) }.getOrElse(new JsonArray())
    sqlClient.queryWithParamsFuture(
      s"""SELECT "id", "created_at", "from", "to", "on", "amount", "description" FROM "transaction"
        |WHERE YEAR("on") = ? AND MONTH("on") = ? $accountClause
        |ORDER BY "on"
      """.stripMargin,
      new JsonArray().add(month.getYear).add(month.getMonthValue).addAll(accountParams)
    ).map { resultSet =>
      resultSet.getResults
        .map { row =>
          StoredTransaction(
            id = Id(row.getLong(0)),
            createdAt = row.getInstant(1),
            transaction = Transaction(
              from = Id(row.getLong(2)),
              to = Id(row.getLong(3)),
              on = LocalDate.parse(row.getString(4), DateTimeFormatter.ISO_DATE),
              amount = Money(row.getInteger(5)),
              description = row.getString(6)
            )
          )
        }
        .toList
    }
  }

  def months: Future[List[YearMonth]] =
    sqlClient.queryFuture(
      """SELECT DISTINCT YEAR("on"), MONTH("on") FROM "transaction"
        |ORDER BY YEAR("on"), MONTH("on")
      """.stripMargin
    ).map { resultSet =>
      resultSet.getResults
        .map { row => YearMonth.of(row.getInteger(0), row.getInteger(1)) }
        .toList
    }

  def create(transaction: Transaction): Future[StoredTransaction] = {
    val createdAt = Instant.now
    for {
      conn <- sqlClient.getConnectionFuture
      _ = conn.setOptions(SQLOptions().setAutoGeneratedKeys(true))
      result <- conn.updateWithParamsFuture(
        """INSERT INTO "transaction" ("created_at", "from", "to", "on", "amount", "description")
          |VALUES (?, ?, ?, ?, ?, ?)
        """.stripMargin,
        new JsonArray()
          .add(createdAt)
          .add(transaction.from.value)
          .add(transaction.to.value)
          .add(transaction.on.atStartOfDay.toInstant(ZoneOffset.UTC))
          .add(transaction.amount.cents)
          .add(transaction.description)
      )
    } yield StoredTransaction(
      id = Id(result.getKeys.getLong(0)),
      createdAt = createdAt,
      transaction = transaction
    )
  }

  def update(id: Id[Transaction], transaction: Transaction): Future[Option[StoredTransaction]] =
    for {
      result <- sqlClient.updateWithParamsFuture(
        """UPDATE "transaction" SET "from" = ?, "to" = ?, "on" = ?, "amount" = ?, "description" = ?
          |WHERE "id" = ?
        """.stripMargin,
        new JsonArray()
          .add(transaction.from.value)
          .add(transaction.to.value)
          .add(transaction.on.atStartOfDay.toInstant(ZoneOffset.UTC))
          .add(transaction.amount.cents)
          .add(transaction.description)
          .add(id.value)
      )
      stored <- result.getUpdated match {
        case 0 => Future.successful(None)
        case 1 => single(id)
      }
    } yield stored
}
