package nickel

import scala.concurrent.{ExecutionContext, Future}

import java.time.format.DateTimeFormatter
import java.time.{Instant, LocalDate, YearMonth, ZoneOffset}

import io.vertx.core.json.JsonArray
import io.vertx.scala.ext.sql.{SQLClient, SQLOptions}

class TransactionRepository(val sqlClient: SQLClient)(implicit val ec: ExecutionContext) {

  def inMonth(month: YearMonth): Future[List[StoredTransaction]] =
    sqlClient.queryWithParamsFuture(
      """SELECT "id", "created_at", "from", "to", "on", "amount", "description" FROM "transaction"
        |WHERE YEAR("on") = ? AND MONTH("on") = ?
        |ORDER BY "on"
      """.stripMargin,
      new JsonArray().add(month.getYear).add(month.getMonthValue)
    ).map { resultSet =>
      resultSet.getResults
        .map { row =>
          StoredTransaction(
            id = Id(row.getLong(0)),
            createdAt = row.getInstant(1),
            transaction = Transaction(
              from = Id(row.getLong(2)),
              to = Id(row.getLong(3)),
              on = LocalDate.parse(row.getString(4), DateTimeFormatter.ISO_DATE),
              amount = Money(row.getInteger(5)),
              description = row.getString(6)
            )
          )
        }
        .toList
    }

  def months: Future[List[YearMonth]] =
    sqlClient.queryFuture(
      """SELECT DISTINCT YEAR("on"), MONTH("on") FROM "transaction"
        |ORDER BY YEAR("on"), MONTH("on")
      """.stripMargin
    ).map { resultSet =>
      resultSet.getResults
        .map { row => YearMonth.of(row.getInteger(0), row.getInteger(1)) }
        .toList
    }

  def create(transaction: Transaction): Future[StoredTransaction] = {
    val createdAt = Instant.now
    for {
      conn <- sqlClient.getConnectionFuture
      _ = conn.setOptions(SQLOptions().setAutoGeneratedKeys(true))
      result <- conn.updateWithParamsFuture(
        """INSERT INTO "transaction" ("created_at", "from", "to", "on", "amount", "description")
          |VALUES (?, ?, ?, ?, ?, ?)
        """.stripMargin,
        new JsonArray()
          .add(createdAt)
          .add(transaction.from.value)
          .add(transaction.to.value)
          .add(transaction.on.atStartOfDay.toInstant(ZoneOffset.UTC))
          .add(transaction.amount.cents)
          .add(transaction.description)
      )
    } yield StoredTransaction(
      id = Id(result.getKeys.getLong(0)),
      createdAt = createdAt,
      transaction = transaction
    )
  }
}
